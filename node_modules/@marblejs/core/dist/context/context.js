"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reader = exports.bindTo = exports.bindEagerlyTo = exports.bindLazilyTo = exports.lookup = exports.resolve = exports.unregister = exports.registerAll = exports.register = exports.createContext = exports.DerivedContextToken = exports.ContextReaderTag = exports.setoidContextToken = exports.ordContextToken = void 0;
const R = require("fp-ts/lib/Reader");
const M = require("fp-ts/lib/Map");
const O = require("fp-ts/lib/Option");
const T = require("fp-ts/lib/Task");
const pipeable_1 = require("fp-ts/lib/pipeable");
const Ord_1 = require("fp-ts/lib/Ord");
const context_token_factory_1 = require("./context.token.factory");
exports.ordContextToken = Ord_1.contramap((t) => t._id)(Ord_1.ordString);
exports.setoidContextToken = { equals: exports.ordContextToken.equals };
var ContextReaderTag;
(function (ContextReaderTag) {
    ContextReaderTag[ContextReaderTag["EAGER_READER"] = 0] = "EAGER_READER";
    ContextReaderTag[ContextReaderTag["LAZY_READER"] = 1] = "LAZY_READER";
})(ContextReaderTag = exports.ContextReaderTag || (exports.ContextReaderTag = {}));
exports.DerivedContextToken = context_token_factory_1.createContextToken('DerivedContext');
const isEagerDependency = (x) => {
    return x.eval && x.tag === ContextReaderTag.EAGER_READER;
};
const isLazyDependency = (x) => {
    return x.eval && x.tag === ContextReaderTag.LAZY_READER;
};
exports.createContext = () => M.empty;
exports.register = (boundDependency) => (context) => M.insertAt(exports.setoidContextToken)(boundDependency.token, boundDependency.dependency)(context);
exports.registerAll = (boundDependencies) => (context) => boundDependencies.reduce((ctx, dependency) => exports.register(dependency)(ctx), context);
/**
 * Unregisters given token from the context
 * @since v3.4.0
 */
exports.unregister = (token) => (context) => M.deleteAt(exports.setoidContextToken)(token)(context);
/**
 * Resolves eager dependencies within the context
 * @since v2.0.0
 */
exports.resolve = (context) => __awaiter(void 0, void 0, void 0, function* () {
    const resolveEagerDependency = ({ token, dependency }) => pipeable_1.pipe(() => pipeable_1.pipe(context, dependency.eval, d => Promise.resolve(d)), T.chain(resolvedDependency => T.fromIO(() => context.set(token, resolvedDependency))));
    for (const [token, dependency] of context) {
        if (!isEagerDependency(dependency))
            continue;
        yield resolveEagerDependency({ token, dependency })();
    }
    return context;
});
/**
 * Lookup the dependency for a token in a `Context`
 * @since v2.0.0
 */
exports.lookup = (context) => (token) => pipeable_1.pipe(M.lookup(exports.ordContextToken)(token, context), O.map(dependency => {
    if (!dependency.eval)
        return dependency;
    const boostrapedDependency = isLazyDependency(dependency)
        ? dependency.eval()(context)
        : dependency.eval(context);
    context.set(token, boostrapedDependency);
    return boostrapedDependency;
}), O.fold(() => pipeable_1.pipe(M.lookup(exports.ordContextToken)(exports.DerivedContextToken, context), O.chain((derivedContext) => exports.lookup(derivedContext)(token))), O.some));
/**
 * Binds context token to a lazy dependency.
 * @since v3.0.0
 */
exports.bindLazilyTo = (token) => (dependency) => ({ token, dependency: { eval: () => dependency, tag: ContextReaderTag.LAZY_READER } });
/**
 * Binds context token to a eager dependency.
 * @since v3.0.0
 */
exports.bindEagerlyTo = (token) => (dependency) => ({ token, dependency: { eval: dependency, tag: ContextReaderTag.EAGER_READER } });
/**
 * An alias to `bindLazilyTo`.
 * Binds context token to a lazy dependency.
 * @since v3.0.0
 */
exports.bindTo = exports.bindLazilyTo;
exports.reader = pipeable_1.pipe(R.ask(), R.map(exports.lookup));
