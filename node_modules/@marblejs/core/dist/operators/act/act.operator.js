"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.act = void 0;
const O = require("fp-ts/lib/Option");
const pipeable_1 = require("fp-ts/lib/pipeable");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const utils_1 = require("../../+internal/utils");
function act(callFn, errorFn) {
    const DEFAULT_ERROR_SUFFIX = '_UNHANDLED_ERROR';
    const getDefaultErrorEvent = (error) => (event) => {
        var _a;
        return rxjs_1.of({
            type: !event.type.includes(DEFAULT_ERROR_SUFFIX)
                ? event.type + DEFAULT_ERROR_SUFFIX
                : event.type,
            error: (_a = utils_1.encodeError(error)) !== null && _a !== void 0 ? _a : true,
            metadata: event.metadata,
        });
    };
    const handleError = (event) => (error) => pipeable_1.pipe(O.fromNullable(errorFn), O.map(fn => fn(error, event)), O.map(res => !rxjs_1.isObservable(res) ? rxjs_1.of(res) : res), O.map(res => res.pipe(operators_1.map(r => { var _a; return (Object.assign(Object.assign({}, r), { error: (_a = r.error) !== null && _a !== void 0 ? _a : true })); }))), O.getOrElse(() => getDefaultErrorEvent(error)(event)));
    return (source) => source.pipe(operators_1.mergeMap(event => rxjs_1.defer(() => {
        try {
            return event.error
                ? handleError(event)(event.error)
                : pipeable_1.pipe(callFn(event), operators_1.catchError(handleError(event)));
        }
        catch (error) {
            return handleError(event)(error);
        }
    })));
}
exports.act = act;
