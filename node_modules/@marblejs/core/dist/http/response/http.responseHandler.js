"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleResponse = void 0;
const url = require("url");
const rxjs_1 = require("rxjs");
const Option_1 = require("fp-ts/lib/Option");
const pipeable_1 = require("fp-ts/lib/pipeable");
const function_1 = require("fp-ts/lib/function");
const http_interface_1 = require("../http.interface");
const utils_1 = require("../../+internal/utils");
const httpRequestMetadataStorage_reader_1 = require("../server/internal-dependencies/httpRequestMetadataStorage.reader");
const testing_1 = require("../../+internal/testing");
const http_responseHeaders_factory_1 = require("./http.responseHeaders.factory");
const http_responseBody_factory_1 = require("./http.responseBody.factory");
exports.handleResponse = (ask) => (res) => (req) => (effectResponse) => {
    if (res.finished) {
        return rxjs_1.EMPTY;
    }
    const status = effectResponse.status || http_interface_1.HttpStatus.OK;
    const path = url.parse(req.url).pathname || '';
    const headersFactoryWithData = http_responseHeaders_factory_1.headersFactory({ body: effectResponse.body, path, status });
    const headers = headersFactoryWithData(effectResponse.headers);
    const bodyFactoryWithHeaders = http_responseBody_factory_1.bodyFactory(headers);
    const body = bodyFactoryWithHeaders(effectResponse.body);
    const testingHeader = testing_1.getTestingRequestIdHeader(req);
    if (testing_1.isTestingMetadataOn()) {
        pipeable_1.pipe(ask(httpRequestMetadataStorage_reader_1.HttpRequestMetadataStorageToken), Option_1.fold(function_1.constVoid, storage => storage.set(testingHeader, req.meta)));
    }
    if (utils_1.isStream(body)) {
        res.writeHead(status, headers);
        body.pipe(res);
    }
    else {
        if (body) {
            res.setHeader('Content-Length', Buffer.byteLength(body));
        }
        res.writeHead(status, headers);
        res.end(body);
    }
    return rxjs_1.EMPTY;
};
