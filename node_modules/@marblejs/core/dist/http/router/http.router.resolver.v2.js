"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRouting = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const pipeable_1 = require("fp-ts/lib/pipeable");
const http_error_effect_1 = require("../error/http.error.effect");
const http_error_model_1 = require("../error/http.error.model");
const context_hook_1 = require("../../context/context.hook");
const http_server_tokens_1 = require("../server/http.server.tokens");
const logger_1 = require("../../logger");
const http_router_query_factory_1 = require("./http.router.query.factory");
const http_router_matcher_1 = require("./http.router.matcher");
const http_router_effects_1 = require("./http.router.effects");
const http_router_helpers_1 = require("./http.router.helpers");
const http_router_combiner_1 = require("./http.router.combiner");
exports.resolveRouting = (routing, ctx) => (output$, error$) => {
    const requestBusSubject = context_hook_1.useContext(http_server_tokens_1.HttpRequestBusToken)(ctx.ask);
    const logger = context_hook_1.useContext(logger_1.LoggerToken)(ctx.ask);
    const close$ = rxjs_1.fromEvent(ctx.client, 'close').pipe(operators_1.take(1), operators_1.share());
    const outputSubject = new rxjs_1.Subject();
    const errorSubject = new rxjs_1.Subject();
    const outputFlow$ = outputSubject.asObservable().pipe(operators_1.mergeMap(data => {
        const stream = output$ ? output$(rxjs_1.of(data), ctx) : rxjs_1.of(data.res);
        return stream.pipe(operators_1.map(res => [res, data.req]));
    }), operators_1.takeUntil(close$));
    const errorFlow$ = errorSubject.asObservable().pipe(operators_1.map(data => http_error_model_1.isHttpRequestError(data.error) ? Object.assign(Object.assign({}, data), { error: data.error.error }) : data), operators_1.mergeMap(data => {
        const stream = error$ ? error$(rxjs_1.of(data), ctx) : http_error_effect_1.defaultError$(rxjs_1.of(data), ctx);
        return stream.pipe(operators_1.map(res => [res, data.req]));
    }), operators_1.takeUntil(close$));
    const subscribeOutput = (stream$) => stream$.subscribe(([res, req]) => req.response.send(res), error => { throw http_error_model_1.unexpectedErrorWhileSendingOutputFactory(error); });
    const subscribeError = (stream$) => stream$.subscribe(([res, req]) => req.response.send(res), error => { throw http_error_model_1.unexpectedErrorWhileSendingErrorFactory(error); });
    subscribeOutput(outputFlow$);
    subscribeError(errorFlow$);
    const bootstrappedRrouting = routing.map(item => (Object.assign(Object.assign({}, item), { methods: Object.entries(item.methods).reduce((acc, [method, methodItem]) => {
            if (!methodItem)
                return { [method]: undefined };
            const { middlewares, effect, parameters, meta } = methodItem;
            const subject = new rxjs_1.Subject();
            const decorate = !(meta === null || meta === void 0 ? void 0 : meta.continuous);
            const middleware = http_router_combiner_1.combineRouteMiddlewares(decorate, errorSubject)(...middlewares);
            logger({
                tag: "http" /* HTTP */,
                type: 'Router',
                message: `Effect mapped: ${item.path || '/'} ${method}`,
            })();
            const output$ = pipeable_1.pipe(subject.asObservable(), e$ => middleware(e$, ctx), e$ => decorate ? http_router_helpers_1.decorateEffect(e$, errorSubject) : e$, e$ => effect(e$, ctx), operators_1.catchError((error, stream) => processError(stream)(error)), operators_1.takeUntil(close$));
            const processError = (originStream$) => (error) => {
                if (!error.request)
                    throw http_error_model_1.errorNotBoundToRequestErrorFactory(error);
                errorSubject.next({ error, req: error.request });
                return originStream$;
            };
            const subscribe = (stream$) => stream$.subscribe(res => {
                if (!res.request)
                    throw http_error_model_1.responseNotBoundToRequestErrorFactory(res);
                outputSubject.next({ res, req: res.request });
            }, error => {
                const type = 'RouterResolver';
                const message = `Unexpected error for Output stream: "${error.name}", "${error.message}"`;
                logger({ tag: "http" /* HTTP */, type, message, level: logger_1.LoggerLevel.ERROR })();
            }, () => {
                const type = 'RouterResolver';
                const message = `Effect stream completes`;
                logger({ tag: "http" /* HTTP */, type, message, level: logger_1.LoggerLevel.DEBUG })();
            });
            subscribe(output$);
            return Object.assign(Object.assign({}, acc), { [method]: { subject, parameters } });
        }, {}) })));
    const find = http_router_matcher_1.matchRoute(bootstrappedRrouting);
    const resolve = (req) => {
        const [urlPath, urlQuery] = req.url.split('?');
        const resolvedRoute = find(urlPath, req.method);
        if (!resolvedRoute) {
            return errorSubject.next({ req, error: http_router_effects_1.ROUTE_NOT_FOUND_ERROR });
        }
        req.query = http_router_query_factory_1.queryParamsFactory(urlQuery);
        req.params = resolvedRoute.params;
        req.meta = {};
        req.meta.path = resolvedRoute.path;
        resolvedRoute.subject.next(req);
        requestBusSubject.next(req);
    };
    return {
        resolve,
        errorSubject,
        outputSubject,
    };
};
