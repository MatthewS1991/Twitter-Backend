"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const http = require("http");
const https = require("https");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const pipeable_1 = require("fp-ts/lib/pipeable");
const context_1 = require("../../context/context");
const effectsContext_factory_1 = require("../../effects/effectsContext.factory");
const testing_1 = require("../../+internal/testing");
const utils_1 = require("../../+internal/utils");
const context_logger_1 = require("../../context/context.logger");
const context_helper_1 = require("../../context/context.helper");
const http_effects_1 = require("../effects/http.effects");
const context_hook_1 = require("../../context/context.hook");
const http_server_tokens_1 = require("./http.server.tokens");
const http_server_event_1 = require("./http.server.event");
// internal dependencies
const httpRequestMetadataStorage_reader_1 = require("./internal-dependencies/httpRequestMetadataStorage.reader");
const httpServerEventStream_reader_1 = require("./internal-dependencies/httpServerEventStream.reader");
exports.createServer = (config) => __awaiter(void 0, void 0, void 0, function* () {
    const { listener, event$, port, hostname, dependencies = [], options = {} } = config;
    const server = options.httpsOptions
        ? https.createServer(options.httpsOptions)
        : http.createServer();
    const boundHttpServerEvent = context_1.bindEagerlyTo(httpServerEventStream_reader_1.HttpServerEventStreamToken)(httpServerEventStream_reader_1.HttpServerEventStream({ server, hostname }));
    const boundHttpServerClient = context_1.bindTo(http_server_tokens_1.HttpServerClientToken)(() => server);
    const boundHttpRequestMetadataStorage = context_1.bindTo(httpRequestMetadataStorage_reader_1.HttpRequestMetadataStorageToken)(httpRequestMetadataStorage_reader_1.HttpRequestMetadataStorage);
    const boundHttpRequestBus = context_1.bindTo(http_server_tokens_1.HttpRequestBusToken)(() => new rxjs_1.Subject());
    const context = yield context_helper_1.contextFactory(boundHttpServerClient, boundHttpServerEvent, boundHttpRequestBus, ...utils_1.insertIf(testing_1.isTestingMetadataOn())(boundHttpRequestMetadataStorage), ...dependencies);
    context_logger_1.logContext("http" /* HTTP */)(context);
    const ask = context_1.lookup(context);
    const ctx = effectsContext_factory_1.createEffectContext({ ask, client: server });
    const httpListener = listener(context);
    const serverEvent$ = context_hook_1.useContext(httpServerEventStream_reader_1.HttpServerEventStreamToken)(ask);
    pipeable_1.pipe(rxjs_1.merge(event$ ? event$(serverEvent$, ctx) : rxjs_1.EMPTY, http_effects_1.listening$(serverEvent$, ctx), http_effects_1.error$(serverEvent$, ctx), http_effects_1.close$(serverEvent$, ctx)), operators_1.takeWhile(e => !http_server_event_1.isCloseEvent(e), true)).subscribe();
    const listen = () => new Promise((resolve, reject) => {
        const runningServer = server.listen(port, hostname);
        // @TODO: bind Routing
        runningServer.on('request', httpListener);
        runningServer.on('close', runningServer.removeAllListeners);
        runningServer.on('error', reject);
        runningServer.on('listening', () => resolve(runningServer));
    });
    listen.context = context;
    return listen;
});
